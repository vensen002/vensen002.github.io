import{_ as p,c as i,b as e,a as n,d as s,e as o,f as t,r as d,o as c}from"./app-DC2AytKD.js";const r={};function u(h,a){const l=d("font");return c(),i("div",null,[a[11]||(a[11]=e(`<h1 id="基础概念" tabindex="-1"><a class="header-anchor" href="#基础概念"><span>基础概念</span></a></h1><h2 id="_1-1编译-反编译" tabindex="-1"><a class="header-anchor" href="#_1-1编译-反编译"><span>1.1编译&amp;反编译</span></a></h2><pre><code>编译：将java源文件(.java)转换成java字节码文件(.class)，这个过程叫做编译。
</code></pre><p>​ 反编译：将字节码文件(.class)转换成java源文件(.java)文件，这个过程就叫做反编译。（反编译后，没有代码注释）</p><blockquote><p>Java中编译使用jdk中的javac命令,反编译需要借助工具来实现。</p></blockquote><h2 id="_1-1-1编译和解释" tabindex="-1"><a class="header-anchor" href="#_1-1-1编译和解释"><span>1.1.1编译和解释</span></a></h2><p>​ 编译和解释是计算机语言运行的两种方式，有些语言是编译执行的，有些语言是解释执行的。它们的区别如下：</p><p>​ 编译执行是一次性把源程序编译成计算机能识别的目标程序，因此计算机执行起来速度非常快，但是编译后的目标程序只能在同一平台下运行。比如用C语言编写的程序，在Windows平台下编译的结果，离开Windows平台将无法正确的运行。</p><p>​ 解释执行的程序是指解释器将源程序逐句翻译的同时逐句执行，因此执行起来速度上不占优势，但是这种程序执行时往往不依赖于特定的平台，通过在不同平台上提供不同的解释器就可以跨平台执行。</p><p>Java源程序到字节码是编译执行的，字节码到机器码是解释执行</p><h2 id="_1-2java注释" tabindex="-1"><a class="header-anchor" href="#_1-2java注释"><span>1.2Java注释</span></a></h2><p>​ 为了让开发者（程序的编写者）与开发者（程序阅读者）之间交流的重要手段，也是对代码的一种说明、解释。提高代码可读性、减少维护成本。注释在编译时不会编译注释的内容</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">// 单行注释,从//开始之后的内容不会被编译。在大多数编辑器（开发工具）中,使用CTRL + /</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">/* 多行注释，由/*开始，可以注释多行内容，每行都有*标注，也可以省略*。到*/</span>结束</span>
<span class="line"> <span class="token operator">*</span>  在大多数编辑器（开发工具）中<span class="token punctuation">,</span>先选中要被注释的内容，再使用<span class="token constant">CTRL</span> <span class="token operator">+</span> <span class="token class-name">Shift</span> <span class="token operator">+</span> <span class="token operator">/</span></span>
<span class="line"> <span class="token operator">*</span><span class="token operator">/</span> </span>
<span class="line"><span class="token doc-comment comment">/** 文档注释，以/**开头，以*/</span>结束。可以包含一些描述信息，这些描述信息都以@开头</span>
<span class="line"> <span class="token operator">*</span>  eg： <span class="token annotation punctuation">@author</span>  作者信息    <span class="token annotation punctuation">@version</span> 版本信息 </span>
<span class="line"> <span class="token operator">*</span>       <span class="token annotation punctuation">@param</span>  参数信息  <span class="token annotation punctuation">@return</span>  返回信息</span>
<span class="line"> <span class="token operator">*</span>      <span class="token annotation punctuation">@date</span>  时间信息 等</span>
<span class="line"> <span class="token operator">*</span><span class="token operator">/</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_1-3命名规范" tabindex="-1"><a class="header-anchor" href="#_1-3命名规范"><span>1.3命名规范</span></a></h2><p>java程序中变量、常量、方法、类、接口、包这些都需要有标识符命名它。命名时有一下规范需要遵守：</p>`,15)),n("ul",null,[a[3]||(a[3]=n("li",null,"标识符由字母、数字、下划线和美元符号($)组成",-1)),a[4]||(a[4]=n("li",null,[s("标识符的首字母"),n("span",{style:{color:"red"}},"不能"),s("是数字，错误示例： 2c")],-1)),n("li",null,[a[1]||(a[1]=s("标识符的命名")),o(l,{color:"red"},{default:t(()=>a[0]||(a[0]=[s("不能")])),_:1}),a[2]||(a[2]=s("是关键字、布尔值(true/false)、null"))]),a[5]||(a[5]=n("li",null,"标识符区分大小写、没有长度限制，但是不要命名过长",-1)),a[6]||(a[6]=n("li",null,[s("注意命名时要"),n("code",null,"见名知意")],-1))]),a[12]||(a[12]=e('<h2 id="_1-3-1命名习惯" tabindex="-1"><a class="header-anchor" href="#_1-3-1命名习惯"><span>1.3.1命名习惯：</span></a></h2><p>​ 1）标识符要符合语义信息</p><p>​ 2）包名所有字母小写</p><p>​ 3）类名、接口名、枚举类名 每个单词首字母大写，其他小写（帕斯卡命名法）</p><p>​ 4）变量名、方法名 第一个单词小写，从第二个单词开始首字母大写（驼峰命名法）</p><p>​ 5）常量：所有字母大写，每个单词间用“_”连接</p><h3 id="帕斯卡命名法" tabindex="-1"><a class="header-anchor" href="#帕斯卡命名法"><span>帕斯卡命名法：</span></a></h3><p>​ 首字母大写，如果有多个单词组成每个单词的首字母都要大写</p><h3 id="驼峰命名法" tabindex="-1"><a class="header-anchor" href="#驼峰命名法"><span>驼峰命名法：</span></a></h3><p>​ 首字母小写，如果由多个单词组成的话除第一个单词外每个单词的首字母大写</p><h1 id="java基础" tabindex="-1"><a class="header-anchor" href="#java基础"><span>Java基础</span></a></h1><h2 id="_1-数据类型" tabindex="-1"><a class="header-anchor" href="#_1-数据类型"><span>1.数据类型</span></a></h2><h3 id="_1-1基本数据类型" tabindex="-1"><a class="header-anchor" href="#_1-1基本数据类型"><span>1.1基本数据类型</span></a></h3><p>​ Java中的基本数据类型有八种，固定的，不能被修改的。分别是：</p><blockquote><p>​ byte、char、short、int、long、float、double、 boolean</p></blockquote><p>​ ![](D:/资料/云创学习日记/daily/20190926 宋红林/img/数据类型.png)</p><p>​ 整数类型的默认值是0，浮点类型的默认值是0.0，字符型的默认值是\\u0000（unicode编码中的空格），布尔类型的默认值是false</p><p>![](D:/资料/云创学习日记/daily/20190926 宋红林/img/数据类型精度.png)</p><h4 id="根据类型所占空间分类" tabindex="-1"><a class="header-anchor" href="#根据类型所占空间分类"><span>根据类型所占空间分类：</span></a></h4><ul><li><code>1个字节</code> --&gt; <code>boolean</code>/<code>byte</code></li><li><code>2个字节</code> --&gt; <code>short</code>/<code>char</code></li><li><code>4个字节</code> --&gt; <code>int </code>/<code>float</code></li><li><code>8个字节</code> --&gt; <code>long</code>/<code>double</code></li></ul>',20)),n("blockquote",null,[o(l,{color:"red"},{default:t(()=>a[7]||(a[7]=[s("注意：")])),_:1}),a[8]||(a[8]=e("<ul><li>String类型不是基本数据类型、是引用数据类型</li><li>char字符类型，赋值时使用单引号<code>&#39;&#39;</code>引住单个字符</li><li>long类型数据以大写L（可以使用小写，但是不推荐）结尾</li><li>float类型数据以F（可以使用小写）结尾</li><li>double类型数据以D（可以使用 小写）结尾</li><li>数值默认是<code>int</code>类型，比如：<code>100</code> 就是<code>int</code></li><li>浮点型默认是<code>double</code>类型</li></ul>",1))]),a[13]||(a[13]=e('<h3 id="_1-2-基本数据类型与引用类型的区别" tabindex="-1"><a class="header-anchor" href="#_1-2-基本数据类型与引用类型的区别"><span>1.2 基本数据类型与引用类型的区别</span></a></h3><p>​ 基本数据类型在栈中存储的是真实数据，而引用数据类型在栈中存储的是数据的地址。（地址是由JVM分配的）</p><h3 id="_1-3-数据类型的转换" tabindex="-1"><a class="header-anchor" href="#_1-3-数据类型的转换"><span>1.3 数据类型的转换</span></a></h3><h4 id="_1-3-1-数据类型的级别" tabindex="-1"><a class="header-anchor" href="#_1-3-1-数据类型的级别"><span>1.3.1 数据类型的级别</span></a></h4><p>​ 存储的位数越多，类型的级别就越高。<code>byte</code>最低，<code>double</code>最高</p><p>![](D:/资料/云创学习日记/daily/20190926 宋红林/img/类型转换.png)</p><blockquote><p>​ 低级别数据类型和高级别数据类型运算时，会将低级别数据类型转换成高级别数据类型，由低向高转换为自动转换（高位补零）</p></blockquote>',7)),n("blockquote",null,[o(l,{color:"red"},{default:t(()=>a[9]||(a[9]=[s("注意：")])),_:1}),a[10]||(a[10]=e("<code>byte</code> + <code>byte</code> 运算后，值是<code>int</code>类型的，<code>short</code> + <code>short</code> 运算后，值是<code>int</code>类型的。<blockquote><p><code>byte</code>和<code>short</code>进行运算后，结果是<code>int</code></p></blockquote>",13))]),a[14]||(a[14]=e(`<blockquote><p>int<code>类型转换为</code>byte<code>，</code>int<code>的低位第一个字节中的8位能够转换为</code>byte<code>，</code>int\`的高位3个字节中的24位数据都会丢失。</p></blockquote><h2 id="_2-常用运算符" tabindex="-1"><a class="header-anchor" href="#_2-常用运算符"><span>2.常用运算符</span></a></h2><h3 id="_2-1-是一步操作-有可能发生强转" tabindex="-1"><a class="header-anchor" href="#_2-1-是一步操作-有可能发生强转"><span>2.1 +=是一步操作，有可能发生强转</span></a></h3><p>​</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">		<span class="token comment">//将10赋值给变量i</span></span>
<span class="line">		<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></span>
<span class="line">		</span>
<span class="line">		</span>
<span class="line">		<span class="token keyword">int</span> i1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">		<span class="token comment">//a += b 等同于 a = a + b; 但是+=是一步操作，有可能发生强转</span></span>
<span class="line">		i1 <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span></span>
<span class="line">	<span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-2" tabindex="-1"><a class="header-anchor" href="#_2-2"><span>2.2 ++/--</span></a></h3><blockquote><p>++/--在前，先运算（自增）再赋值。++/--在后先赋值再运算</p></blockquote>`,7))])}const k=p(r,[["render",u],["__file","index copy.html.vue"]]),b=JSON.parse('{"path":"/docs/java/index copy.html","title":"基础概念","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"1.1编译&反编译","slug":"_1-1编译-反编译","link":"#_1-1编译-反编译","children":[]},{"level":2,"title":"1.1.1编译和解释","slug":"_1-1-1编译和解释","link":"#_1-1-1编译和解释","children":[]},{"level":2,"title":"1.2Java注释","slug":"_1-2java注释","link":"#_1-2java注释","children":[]},{"level":2,"title":"1.3命名规范","slug":"_1-3命名规范","link":"#_1-3命名规范","children":[]},{"level":2,"title":"1.3.1命名习惯：","slug":"_1-3-1命名习惯","link":"#_1-3-1命名习惯","children":[{"level":3,"title":"帕斯卡命名法：","slug":"帕斯卡命名法","link":"#帕斯卡命名法","children":[]},{"level":3,"title":"驼峰命名法：","slug":"驼峰命名法","link":"#驼峰命名法","children":[]}]},{"level":2,"title":"1.数据类型","slug":"_1-数据类型","link":"#_1-数据类型","children":[{"level":3,"title":"1.1基本数据类型","slug":"_1-1基本数据类型","link":"#_1-1基本数据类型","children":[]},{"level":3,"title":"1.2 基本数据类型与引用类型的区别","slug":"_1-2-基本数据类型与引用类型的区别","link":"#_1-2-基本数据类型与引用类型的区别","children":[]},{"level":3,"title":"1.3 数据类型的转换","slug":"_1-3-数据类型的转换","link":"#_1-3-数据类型的转换","children":[]}]},{"level":2,"title":"2.常用运算符","slug":"_2-常用运算符","link":"#_2-常用运算符","children":[{"level":3,"title":"2.1 +=是一步操作，有可能发生强转","slug":"_2-1-是一步操作-有可能发生强转","link":"#_2-1-是一步操作-有可能发生强转","children":[]},{"level":3,"title":"2.2 ++/--","slug":"_2-2","link":"#_2-2","children":[]}]}],"git":{"createdTime":1734637665000,"updatedTime":1734637665000,"contributors":[{"name":"vensen","email":"vensen002@outlook.com","commits":1}]},"filePathRelative":"docs/java/index copy.md"}');export{k as comp,b as data};
